(* --------------------------------------------------------------------
 * Copyright (c) - 2006--2012 - IMDEA Software Institute
 * Copyright (c) - 2006--2012 - Inria
 * Copyright (c) - 2006--2012 - Microsoft Coprporation
 *
 * Distributed under the terms of the CeCILL-B-V1 license
 * -------------------------------------------------------------------- *)

Require Export Triples.
Require Export SD.

Set Implicit Arguments.

(*********************************************************************)
(* Here we present two results that allows us to bound the statis-   *)
(* tical distance generated by two upto-bad programs and by the call *)
(* to an adversary                                                   *)
(*********************************************************************)



(* *********************** SOME AUXILIARY STUFF *********************** *)
(* ******************************************************************** *)

 Lemma Uplus_le_minus: forall a b c,
  a - b <= c -> a <= c + b.
 Proof.
   intros.
   apply (Ule_total a b); [auto|intro H'|intro H'].
     rewrite (Uminus_plus_le a b), (Uminus_le_zero _ _ H'); auto.
     apply (Uminus_le_perm_left _ _ _ H' H).
 Qed.


 Lemma Uabs_diff_le_intro: forall a b c,
    a <= c + b ->
    b <= c + a ->
    Uabs_diff a b <= c.
 Proof.
  intros a b c Ha Hb.
  unfold Uabs_diff.
  apply (Ule_total a b); [auto|intro H''|intro H''].
    rewrite (Uminus_le_zero _ _ H''); Usimpl.
    rewrite Hb; auto.
    rewrite (Uminus_le_zero _ _ H''); Usimpl.
    rewrite Ha; auto.
 Qed.

 Lemma Uabs_diff_le_lub_compat : forall (f g h: natO -m> U),
  (forall n, Uabs_diff (f n) (g n) <= h n) ->
  Uabs_diff (lub f) (lub g) <= lub h. 
 Proof.
  intros.
  apply Uabs_diff_le_intro.
    apply lub_le; intro n.
    transitivity (h n + g n).
      apply Uplus_le_minus; rewrite <-H; apply Ule_plus_right.
      apply Uplus_le_compat; apply le_lub.
    apply lub_le; intro n.
    transitivity (h n + f n).
      apply Uplus_le_minus; rewrite <-H; apply Ule_plus_left.
      apply Uplus_le_compat; apply le_lub.
 Qed.

 Lemma mu_stable_plus_range: forall (A:Type) (d:Distr A) R,
   range R d ->
   forall f g,
   (forall a, R a ->  g a <= [1-] f a) ->
   mu d (fplus f g) == mu d f + mu d g.
 Proof.
  intros; split.
    auto.
    transitivity (mu d (fminus (fplus f g) g) + mu d g).
      Usimpl.
      apply range_le with (1:=H).
      intros a Ha; unfold fminus, fplus.
      rewrite Uplus_minus_simpl_right; auto.
      rewrite <-(@mu_stable_plus _ d _ _); unfold fminus, fplus.
        apply range_le with (1:=H).
        intros a _; rewrite Uminus_plus_simpl; auto.
        unfold fplusok, finv; refine (ford_le_intro _); intro a.
        rewrite <-Uminus_one_left.
        apply Uminus_le_compat_left; trivial.
 Qed.

 Lemma sigma_monot: forall (f g: nat -> U) (n m : nat),
   (n <= m)%nat -> 
   (forall k, (k<n)%nat -> f k <= g k) ->
   (sigma f) n <= (sigma g) m.
 Proof.
   intros f g n m Hnm Hfg.
   rewrite (@sigma_le_compat  _ _  _ Hfg).
   exact (sigma_incr _ Hnm).
 Qed.

(* 
   TODO: unify [sum_f] with the similar definition
   given in Triples.v 

   Definition sum_over_nat (Min Max:nat) (f:nat -> U) 
     := (sigma (fun n => f (Max - S n)) (Max - Min))%nat.
*)

 (* sums up [ f(Min) + ... +  f(pred Max) ] *)
 Definition sum_f (Min Max:nat) (f:nat -> U) 
   := finite_sum f (seq Min (Max - Min)).

 Lemma sum_f_split: forall (a b c:nat) f,
   (a <= c)%nat ->
   (c <= b)%nat ->
   sum_f a b f == sum_f a c f + sum_f c b f.
 Proof.
  intros a b c f Hab Hcb; unfold sum_f.
  replace (b-a)%nat with  ((c - a) + (b - c))%nat by omega.
  rewrite seq_append, (le_plus_minus_r _ _ Hab).
   apply finite_sum_app.
 Qed.

 Lemma sum_f_empty: forall (a b:nat) f,
   (b <= a)%nat ->
   sum_f a b f == 0.
 Proof.  
  intros; unfold sum_f.
  replace (b-a)%nat with 0%nat by omega; trivial.
 Qed.

 Lemma sum_f_non_empty: forall f a n, 
   (a <= n)%nat -> 
   sum_f a (S n) f == f n + sum_f a n f.
 Proof.
  intros.
  rewrite (@sum_f_split _ _ n); [ Usimpl | auto | auto ].
  unfold sum_f.
  rewrite <-(minus_Sn_m _ _ (le_refl _)), minus_diag.
  simpl; auto.
 Qed.

 Lemma sum_f_cte: forall (f:nat->U) (a b : nat) m,
    (forall k, (a<=k)%nat -> (k<b)%nat -> f k == m) -> 
    sum_f a b f == (b-a) */ m.
 Proof.
  intros.
  destruct (le_lt_dec a b) as [H' | H'].
    (* a<=b *)
    assert (Hb: (b = a + (b-a))%nat) by apply (le_plus_minus _ _ H').
    assert (Hf: forall k : nat, (a <= k)%nat -> (k < a+(b-a))%nat -> f k == m) by
      (intros k Ha Hb'; apply (H _ Ha); rewrite Hb; trivial).
    unfold sum_f.
    clear H Hb.
    induction (b-a)%nat.
      trivial.
      rewrite seq_S, finite_sum_app; unfold finite_sum at 2, fold_right.
      rewrite IHn; [ | intros k Ha Hb; apply Hf; [ trivial | omega ] ].
      rewrite Hf, Uplus_zero_right, Uplus_sym, Nmult_S; trivial; omega.
    (* a>b *)
    rewrite (sum_f_empty _ (lt_le_weak _ _ H')).
    rewrite (not_le_minus_0 _ _ (gt_not_le _ _ H')).
    trivial.
 Qed.

 Lemma sum_f_le_compat: forall (f g:nat->U) (a b : nat),
    (forall k, (a<=k)%nat -> (k<b)%nat -> f k <= g k) -> 
    sum_f a b f <= sum_f a b g.
 Proof.
  intros.
  destruct (le_lt_dec a b) as [H' | H'].
    (* a<=b *)
    assert (Hb: (b = a + (b-a))%nat) by apply (le_plus_minus _ _ H').
    assert (Hf: forall k : nat, (a <= k)%nat -> (k < a+(b-a))%nat -> f k <= g k) by
      (intros k Ha Hb'; apply (H _ Ha); rewrite Hb; trivial).
    unfold sum_f.
    clear H Hb.
    induction (b-a)%nat.
      trivial.
      rewrite seq_S, finite_sum_app, finite_sum_app;
        unfold finite_sum at 2 4, fold_right.
      rewrite IHn; [ | intros k Ha Hb; apply Hf; [ trivial | omega ] ].
      rewrite Hf; trivial; omega.
    (* a>b *)
    rewrite (sum_f_empty _ (lt_le_weak _ _ H')); trivial.
 Qed.


 Lemma sum_f_monot: forall (min max min' max':nat) f,
   (min' <= min)%nat ->
   (max <= max')%nat ->
   sum_f min max f <= sum_f min' max' f.
 Proof.
  intros mi ma mi' ma' f Hmi Hma.
  destruct (le_lt_dec ma mi) as [H | H].
    rewrite (sum_f_empty _ H); auto.
    rewrite (@sum_f_split mi' ma' ma _); [ | omega | trivial ].
    rewrite (@sum_f_split mi' ma mi _); [ | omega | omega ].
    rewrite <-Uplus_assoc, Uplus_sym, <-Uplus_assoc; auto.
 Qed.

 Lemma sum_f_0_sigma: forall b f, 
   sum_f 0 b f == (sigma f) b.
 Proof.
  intros; unfold sum_f.
  rewrite <-(@sigma_finite_sum _ 0%nat).
  rewrite <-minus_n_O, seq_length.  
  apply sigma_eq_compat.
  intros; rewrite (seq_nth _ _ H); auto.
 Qed.

 Lemma wretract_sum_f: forall f,
   wretract f ->
   forall a b c, sum_f a b f <= [1-] sum_f b c f.
 Proof.
  intros f Hf a b c.
  destruct (le_lt_dec b a) as [H1 | H1 ];
    [ rewrite (sum_f_empty _ H1); auto | ].
  destruct (le_lt_dec c b) as [H2 | H2 ];
    [ rewrite (sum_f_empty _ H2); auto | ].
  apply Uinv_le_perm_right.
  replace c with (b + S (pred (c - b)))%nat by omega.
  generalize (pred (c-b)); clear c H2;
    intro n; generalize n a b H1; clear H1 a b n.
  induction n; intros a b Hab.
    (* case [n = 0] *) 
    rewrite plus_comm, (sum_f_non_empty _ (le_refl b)), 
      (sum_f_empty  _ (le_refl b)); Usimpl.
    rewrite (Hf b); apply Uinv_le_compat.  
    rewrite (sum_f_monot _ (le_0_n _) (le_refl _)).
    apply sum_f_0_sigma.
    (* inductive case *)
    rewrite plus_comm, plus_Sn_m, (sum_f_non_empty _ (le_plus_r _ _)).
    transitivity ([1-] (sum_f a b f + sum_f b (S n + b) f) + sum_f b (S n + b) f).
      Usimpl; rewrite (Hf (S n + b)%nat); Usimpl.
      rewrite <-sum_f_split; [ | apply (lt_le_weak _ _ Hab) | apply le_plus_r ].
      rewrite (sum_f_monot _ (le_0_n _) (le_refl _)).
      apply sum_f_0_sigma.
    apply Uinv_plus_right.
    rewrite plus_comm; apply (IHn _ _ Hab).
 Qed.

(* ******************************************************************** *)
(* ******************************************************************** *)

 

Module Make(SemO:SEM_OPT).

 Module OPT1 := Triples.Make SemO.
 Export OPT1.


 Definition compR (R S:mem_rel) : mem_rel := 
   fun k => rcomp (@R k) (@S k) .
 Notation "P '|o|' Q" := (compR P Q) (at level 40).

 Lemma compR_r_Meq: forall P,
   iffMR (P |o| Meq) P.
 Proof.
  unfold compR, rcomp; split; intros k m1 m2.
    intros [b [Hb1 Hb2] ]; rewrite <-Hb2; trivial.
    intros H; eauto.
 Qed.
  
 Lemma compR_l_Meq: forall P,
   iffMR (Meq |o| P) P.
 Proof.
  unfold compR, rcomp; split; intros k m1 m2.
    intros [b [Hb1 Hb2] ]; rewrite Hb1; trivial.
    intros H; eauto.
 Qed.
  
 Definition prg_SD (P:mem_rel) E1 (c1:cmd) E2 (c2:cmd) (Q:mem_rel) (ep: nat -o> U) :=
   forall k (f g : Mem.t k -> U),
   (forall m1 m2 : Mem.t k, Q _ m1 m2 -> f m1 == g m2) ->
    forall m1 m2 : Mem.t k,
    P _ m1 m2 ->
    Uabs_diff (mu ([[ c1 ]] E1 m1) f) (mu ([[c2]] E2 m2) g) <= ep k.
 
 Lemma prg_SD_weaken: forall (P P' Q Q':mem_rel) E1 E2 (c1 c2:cmd) (ep ep': nat -o> U),
   implMR P' P ->
   implMR Q Q' ->
   ep <= ep' ->
   prg_SD P E1 c1 E2 c2 Q  ep ->
   prg_SD P' E1 c1 E2 c2 Q' ep'.
 Proof.
  intros P P' Q Q' E1 E2 c1 c2 ep ep' H1 H2 H3 H4 k f g Hfg m1 m2 Hm.
  rewrite <-(H3 k); apply H4; auto.
 Qed.

 Add Parametric Morphism: prg_SD  with signature 
   implMR --> (@eq env) ==> (@eq cmd) ==> 
   (@eq env) ==> (@eq cmd) ==> implMR ++> @Ole (ford nat (tcpo U)) ==> impl as prg_SD_imp.
 Proof.
  intros P P' HP e1 c1 e2 c2 Q Q' HQ ep ep' Hep H.
  eapply prg_SD_weaken with (4:=H); assumption.
 Qed.


 Add Parametric Morphism: prg_SD  with signature 
   iffMR ==> (@eq env) ==> (@eq cmd) ==> 
   (@eq env) ==> (@eq cmd) ==> iffMR ==> (@Oeq (ford nat (tcpo U))) ==> iff as prg_SD_iff.
 Proof.
  intros P P' [HPl HPr] e1 c1 e2 c2 Q Q' [HQl HQr] ep ep' [Hepl Hepr]; split; intro H.
    apply prg_SD_weaken with (4:=H); trivial.
    apply prg_SD_weaken with (4:=H); trivial.
 Qed.

 Lemma prg_SD_seq_Meq: forall (P Q:mem_rel) E1 E2 (c1 c2 c1' c2':cmd) 
  (ep ep': nat -o> U),
  prg_SD P  E1 c1  E2 c2  Meq ep ->
  prg_SD Meq E1 c1' E2 c2' Q  ep' ->
  prg_SD P  E1 (c1++c1')  E2 (c2++c2') Q (fplus ep ep').
 Proof.
  unfold prg_SD, fplus; intros.
  repeat rewrite deno_app_elim.
  rewrite (@Uabs_diff_triangle_ineq _ _ (mu ([[c1]] E1 m1) (fun m' => mu ([[c2']] E2 m') g))).
  rewrite (Uplus_sym (ep k)); apply Uplus_le_compat.
  rewrite Uabs_diff_mu_compat, <-(mu_cte_le ([[c1]] E1 m1) (ep' k)).
  apply equiv_deno_le with Meq Meq; trivial.
  apply equiv_eq_mem.
  unfold fabs_diff, fcte; intros; apply H0; trivial.
  apply H; trivial.
  intros; apply equiv_deno with Meq Meq; trivial.
  apply equiv_eq_mem.
  intros; rewrite H4; trivial.
 Qed.

 Lemma prg_SD_Meq_pre_weaken: forall (P Q:mem_rel) E1 E2  (c1 c2:cmd) 
  (ep:nat -o> U),
  prg_SD Meq E1 c1 E2 c2 Q ep ->
  prg_SD Meq E1 c1 E1 c1 Q (fzero _) ->
  prg_SD P E2 c2 E2 c2 Q (fzero _) ->
  symMR Q ->
  prg_SD P E1 c1  E2 c2 Q ep.
 Proof.
  unfold prg_SD; intros.
  match goal with 
   |- (Uabs_diff ?x ?y <= _)%tord =>
    rewrite (@Uabs_diff_triangle_ineq x y (mu ([[c1]] E1 m1) g)),
     (@Uabs_diff_triangle_ineq (mu ([[c1]] E1 m1) g) y (mu ([[c2]] E2 m1) f))
  end.
  match goal with 
   |- ( (?x + (?y + ?z))%U <= _)%tord  => 
    assert ((x==0%U)%tord); [ | assert ((z==0%U)%tord) ] 
  end.
  apply Ule_zero_eq; apply H0; trivial.
  apply Ule_zero_eq; apply H1; trivial.
  rewrite H5, H6; repeat Usimpl; apply H; trivial.
  intros m1' m2' H'; symmetry; apply (H3 _ _ (proj2 H2 _ _ _ H')).
 Qed.

 Lemma prg_SD_trans: forall (P P' Q Q' Q'':mem_rel) E1 E2 E3  (c1 c2 c3:cmd) (ep ep': nat -o> U),
   implMR Q Q'' ->
   implMR Q' Q'' ->
   refl_supMR2 Q' Q'' ->
   prg_SD P E1 c1 E2 c2 Q  ep ->
   prg_SD P' E2 c2 E3 c3 Q' ep' ->
   prg_SD (P |o| P') E1 c1 E3 c3 Q'' (fplus ep ep').
 Proof.
  intros; unfold prg_SD, compR, rcomp in *; 
    intros k f g Hfg m1 m3 [m2 [Hm2 Hm2'] ].
  rewrite (@Uabs_diff_triangle_ineq _ _ (mu ([[c2]] E2 m2) g)).
  apply Uplus_le_compat.
    apply H2; auto.
    apply H3.
      intros; transitivity (f m0); [ symmetry | ]; apply Hfg;
        [ apply (H1 _ m0 m4 H4) | auto ].
      trivial.
 Qed.

 Lemma prg_SD_trans_Meq: forall (P P' Q:mem_rel) E1 E2 E3  (c1 c2 c3:cmd) (ep ep': nat -o> U),
   prg_SD P E1 c1 E2 c2 Q  ep ->
   prg_SD P' E2 c2 E3 c3 Meq ep' ->
   prg_SD (P |o| P') E1 c1 E3 c3 Q (fplus ep ep').
 Proof.
  intros; unfold prg_SD, compR, rcomp in *; 
    intros k f g Hfg m1 m3 [m2 [Hm2 Hm2'] ].
  rewrite (@Uabs_diff_triangle_ineq _ _ (mu ([[c2]] E2 m2) g)).
  apply Uplus_le_compat.
    apply H; auto.
    apply H0.
      intros m1' m2' Hm'; rewrite Hm'; trivial.
      trivial.
 Qed.

 Lemma prg_SD_trans_PER: forall (P Q:mem_rel) E1 E2 E3 (c1 c2 c3:cmd) (ep ep': nat -o> U),
   (forall k, @RelationClasses.PER _ (@P k)) ->
   (forall k, @RelationClasses.PER _ (@Q k)) ->
   prg_SD P E1 c1 E2 c2 Q ep ->
   prg_SD P E2 c2 E3 c3 Q ep' ->
   prg_SD P E1 c1 E3 c3 Q (fplus ep ep').
 Proof.
  intros.
  apply prg_SD_weaken with (P |o| P) Q (fplus ep ep'); trivial.
    intros k; apply (proj1 (rcomp_PER (H k))).
  apply prg_SD_trans with (4:=H1) (5:=H2); trivial.
    intros k m1 m2; apply (PER_l _ _ (H0 k)).
 Qed.

 Lemma prg_trans_Meq_Meq: forall P E1 c1 E2 c2 Q ep ep',
   prg_SD P E1 c1 E1 c1 Q ep ->
   prg_SD Meq E1 c1 E2 c2 Meq ep' ->
   prg_SD P E1 c1 E2 c2 Q (fplus ep ep').
 Proof.
  intros.
  apply prg_SD_weaken with (P |o| Meq) (Q |o| Meq) (fplus ep ep'); trivial.
    apply (proj2 (compR_r_Meq P)).
    apply (proj1 (compR_r_Meq Q)).
  apply  prg_SD_trans_Meq with (E2:=E1) (c2:=c1).
    apply prg_SD_weaken with P Q ep; [ trivial | apply (proj2 (compR_r_Meq Q)) | trivial | ].
    assumption.
    assumption.
 Qed.
 



Section RTRIPLE.
  
 Variable k : nat.
 Variable e1 e2 : env.

 Definition rtriple c1 c2 (g:Mem.t k -> U) := forall (m:Mem.t k) f, 
   Uabs_diff (mu ([[c1]] e1 m) f) (mu ([[c2]] e2 m) f)  <= g m.

 Notation "'[|' c1 ',' c2  '|]' '<~' g" := (rtriple c1 c2 g) (at level 50).

 Lemma rtriple_weaken : forall (g g':Mem.t k -o> U) c1 c2,
   g' <= g -> 
   [| c1,c2 |] <~ g' ->
   [| c1,c2 |] <~ g.
 Proof.
  unfold rtriple; intros.
  rewrite <-(H m); auto.
 Qed.


 Lemma rtriple_ass : forall t (x:Var.var t) e,
   [| [x <- e], [x <- e] |] <~ fzero _.
 Proof.   
  unfold rtriple; intros.
  repeat rewrite deno_assign_elim; auto.
 Qed.

 Lemma rtriple_rand : forall t (x:Var.var t) s,
   [| [x <$- s], [x <$- s] |] <~ fzero _.
 Proof.
  unfold rtriple; intros.
  repeat rewrite deno_random_elim; auto.
 Qed.

 Lemma rtriple_cond : forall (e:E.expr T.Bool) c1 c1' c2 c2' g,
   [| c1,c1' |] <~ g -> 
   [| c2,c2' |] <~ g -> 
   [| [If e then c1 else c2], [If e then c1' else c2'] |] <~ g. 
  Proof.
   unfold rtriple; intros.
   repeat rewrite deno_cond_elim.
   case (E.eval_expr e m); auto.
 Qed.

 Lemma rtriple_scond : forall (e:E.expr T.Bool) c1 c1' c2 c2' g1 g2,
   [| c1,c1' |] <~ g1 -> 
   [| c2,c2' |] <~ g2 -> 
   [| [If e then c1 else c2], [If e then c1' else c2'] |] <~ 
   (fun m => if E.eval_expr e m then g1 m else g2 m).
  Proof.
   unfold rtriple; intros.
   repeat rewrite deno_cond_elim.
   case (E.eval_expr e m); auto.
 Qed.

 Lemma rtriple_nil: [| nil, nil |] <~ fzero _.
 Proof.
   unfold rtriple; intros.
   repeat rewrite deno_nil_elim; auto.
 Qed.

 Lemma rtriple_app: forall c1 c2 c1' c2' g h,
   [| c1, c2 |] <~ h -> 
   [| c1', c2' |] <~ g -> 
   [| c1++c1',c2++c2' |] <~ fun (m:Mem.t k) => mu ([[c1]] e1 m) g + h m.
 Proof.
  unfold rtriple; intros.
  repeat rewrite deno_app_elim.
  rewrite (Uabs_diff_triangle_ineq _ _ (mu ([[c1]] e1 m) (fun m' => mu ([[c2']] e2 m') f))).
  apply Uplus_le_compat.
    rewrite Uabs_diff_mu_compat. 
    refine (mu_monotonic _ _ _ _); refine (ford_le_intro _). 
    intro m'; unfold fabs_diff; apply H0.
    apply H.
 Qed.


 Fixpoint iter_fun (c:cmd) (b:E.expr T.Bool) (E:env) 
   (h:Mem.t k -o> U) (n:nat) {struct n} : Mem.t k -o> U :=
  match n with
   | O => fzero (Mem.t k)
   | S n => fun m => if E.eval_expr b m then
     mu ([[c]] E m) (iter_fun c b E h n) + h m else 0
  end.

 Lemma iter_fun_monot: forall c b E g m n, 
   iter_fun c b E g n m <= iter_fun c b E g (S n) m.
 Proof.
  intros; generalize m; clear m.
  induction n; intros m.
    auto.
    change (iter_fun c b E g (S n) m) with 
      (if E.eval_expr b m then
     mu ([[c]] E m) (iter_fun c b E g n) + g m else 0).
    change (iter_fun c b E g  (S (S n)) m) with 
      (if E.eval_expr b m then
     mu ([[c]] E m) (iter_fun c b E g  (S n)) + g m else 0).
    case (E.eval_expr b m); auto.
 Qed.


 Lemma rtriple_while: forall c1 c2 b g,
   [| c1, c2 |] <~ g -> 
   [| [while b do c1], [while b do c2] |] <~ 
     fun m => lub (c:=U) (fnatO_intro (iter_fun_monot c1 b e1 g m)).
 Proof.
  unfold rtriple; intros.
  repeat rewrite deno_while_unfold_elim. 
  apply Uabs_diff_le_lub_compat.
  intro n; simpl.
  match goal with 
    |- Uabs_diff (fmonot (mu _) ?f1)  (fmonot (mu _) ?f1) <= _ => 
      generalize m f1; clear m f 
  end.
  induction n; intros m f.
    simpl; repeat rewrite (deno_cond_elim _ _ _ _ m).
    case (E.eval_expr b m); repeat rewrite deno_nil_elim; auto.
    unfold unroll_while; fold (unroll_while b c1 n) (unroll_while b c2 n).
    unfold iter_fun; fold (iter_fun c1 b e1 g n).  
    apply (rtriple_scond b (rtriple_app H IHn) rtriple_nil).
 Qed.

(* 
 Lemma rtriple_call : forall t (p:Proc.proc t) (x:Var.var t) arg X g,
   proc_params e1 p = proc_params e2 p ->
   proc_res e1 p = proc_res e2 p ->
   depend_only_f g X ->
   (forall x, Vset.mem x X -> Var.is_global x) -> 
   [| (proc_body e1 p), (proc_body e2 p) |] <~ g -> 
   [| [x <c- p with arg], [x <c- p with arg] |] <~ g.
 Proof.
  unfold rtriple; intros.
  repeat rewrite deno_call_elim.
  rewrite <-(init_mem_eq2 e1 _ _ arg _ _ H); trivial.
  rewrite (mu_stable_eq ([[proc_body e2 p]] e2 (init_mem e1 p arg m)) _ 
    (fun m' => f (return_mem e1 x p m m'))); [ | refine (ford_eq_intro _); 
      intro m'; rewrite (return_mem_eq _ _ _ _ _ _ H0); trivial ].
  rewrite H3.
  apply Oeq_le; apply H1.
  red; intros; apply init_mem_global; auto.
 Qed.
*)




(********************************************************************)
(* *** The classical statistical distance between two upto-bad  *** *)
(* *****  programs can be bounded by the probability of [bad] ***** *)
(********************************************************************)
 Section UPTO_BAD.

 Lemma Fundamental_Lemma_GSD : forall E1 E2 c1 c2 k (m:Mem.t k) F,
   (forall P,  Pr E1 c1 m (P[&&]negP F) == Pr E2 c2 m (P[&&]negP F)) ->
   Pr E1 c1 m F <= Pr E2 c2 m F ->
   GSD ([[c1]] E1 m) ([[c2]] E2 m) (Pr E2 c2 m F).
 Proof.
  intros.
  eapply GSD_le_SD.
    apply mem_eqU_spec.
    apply sem_discr.  
    apply sem_discr.
    unfold SD; intros.
    apply Fundamental_Lemma.
    apply H.
    assumption.
 Qed.


 Lemma upto_bad_GSD : forall bad : Var.var T.Bool,
       Var.is_global bad ->
       forall (pi : upto_info bad e1 e2) (c1 c2 : cmd),
       check_bad pi c1 c2 ->
       lossless e2 c2 ->
       [| c1, c2 |] <~ fun m => Pr e2 c2 m (EP k bad).
 Proof.
  unfold rtriple; intros.
  generalize (Oeq_refl f); generalize f at 2 4; generalize f; clear f;
  change  (GSD ([[c1]] e1 m) ([[c2]] e2 m) (Pr e2 c2 m (EP k bad))). 
  apply Fundamental_Lemma_GSD; intros.
  rewrite andP_comm; unfold Pr.
  transitivity (mu (([[ c1 ]]) e1 m) (restr (negP (EP k bad)) (charfun P)));
  [ apply mu_stable_eq; symmetry; apply restr_charfun_and | ].
  transitivity (mu (([[ c2 ]]) e2 m) (restr (negP (EP k bad)) (charfun P)));
  [ | apply mu_stable_eq; apply restr_charfun_and].
  unfold check_bad in H0.
  repeat (rewrite is_true_andb in H0; destruct H0).
  apply upto_bad_correct with pi; trivial; destruct pi; trivial.
  rewrite <- (negP_involutive (EP k bad)).
  unfold Pr.
  rewrite mu_neg_charfun, (fun d => mu_neg_charfun d (negP (EP k bad))).
  unfold fone; unfold lossless in H1; rewrite H1.
  fold (Pr e1 c1 m (negP (EP k bad))).
  rewrite (upto_bad_neg_bad H pi c1 c2); unfold Pr; auto.
 Qed.

 End UPTO_BAD.


 Section ADVERSARY.

  Variables PrOrcl PrPriv : PrSet.t.
  Variables Gadv Gcomm :Vset.t.

  Definition all_orc_lossless := forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl -> lossless e1 (proc_body e1 p).


  (* Hypoteses about the invariant *)
  Variable S: Mem.t k -> Mem.t k -> Prop.
  Hypothesis S_compat_glob_var: forall (m1 m2 m1' m2':Mem.t k),
    S m1 m2 ->
    (forall t (x:Var.var t), Var.is_global x -> m1 x = m1' x) ->
    (forall t (x:Var.var t), Var.is_global x -> ~ Vset.mem x Gadv -> m2 x = m2' x) ->
    S m1' m2'.
  Hypothesis S_refl: forall m, S m m. 
  Hypothesis S_trans: forall m1 m2 m3,
    S m1 m2 -> S m2 m3 -> S m1 m3.


  (* Hypotheses about the bounding function *)
  Variable p:Mem.t k -> Mem.t k -o> U.

  Let F c E := (fun m => mu ([[c]] E m) (fun m' => p m m')): Mem.t k -o> U.

  Hypothesis F_app_compat: forall (c1 c1' : cmd),
    lossless e1 c1' ->
    (forall m, range (fun m' => S m m') ([[ c1 ]] e1 m)) ->
    (forall m, range (fun m' => S m m') ([[ c1' ]] e1 m)) ->
    forall m, 
      F c1 e1 m + mu ([[c1]] e1 m) (F c1' e1) <= F (c1 ++ c1') e1 m.

  Hypothesis F_if_compat: forall c1 c2 (b:E.expr T.Bool) (m:Mem.t k), 
    (if E.eval_expr b m then F c1 e1 m else F c2 e1 m) <=
    F [If b then c1 else c2] e1 m.

  Hypothesis F_calls_compat: forall t (x: Var.var t),
    WFWrite Gadv x ->
    forall (f: Proc.proc t) args m,
    F (proc_body e1 f) e1 (init_mem e1 f args m) <= F [x <c- f with args] e1 m.

  Lemma range_unroll_while: forall c e,
    (forall m, range (fun m' : Mem.t k => S m m') (([[ c ]]) e1 m)) ->
    forall n m , range (fun m' : Mem.t k => S m m') (([[ unroll_while e c n ]]) e1 m).
  Proof.
   intros c e H; induction n; intros m f Hf; simpl.
     rewrite (deno_cond_elim _ _ _ _ m). 
     case (E.eval_expr e m); rewrite deno_nil_elim; apply (Hf _ (S_refl _)).
     rewrite (deno_cond_elim _ _ _ _ m). 
     case (E.eval_expr e m). 
       rewrite deno_app_elim; apply H; intros m'' Hm'';
       apply (IHn _ _ (fun m''' Hm''' => Hf _ (S_trans Hm'' Hm'''))).
       rewrite deno_nil_elim; apply (Hf _ (S_refl _)).
  Qed.


  (* Hypotheses about the environments *)
  Hypothesis procs_params_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_params e1 p = proc_params e2 p.
  Hypothesis procs_res_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_res e1 p = proc_res e2 p.
  Hypothesis decl_Adv: Eq_adv_decl PrOrcl PrPriv e1 e2.


  (* Hypotheses about the oracles *)  
  Hypothesis Orcl_dist: forall t  (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   [| (proc_body e1 p), (proc_body e2 p) |] <~ F (proc_body e1 p) e1.
  Hypothesis Orcl_range: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   forall m, range (fun m' => S m m') ([[proc_body e1 p]] e1 m).


  Lemma rtriple_adv : forall ca I O,
    WFAdv_c PrOrcl PrPriv Gadv Gcomm e1 I ca O ->
    slossless_c e1 ca ->
    (forall x, Vset.mem x I -> Var.is_local x) ->
       [| ca,ca |] <~ F ca e1 /\ 
       (forall m, range (fun m' => S m m') ([[ ca ]] e1 m)).
   Proof.
    intros c I O Hwf Hsl Hloc.
    generalize (eq_refl c); generalize c at 2 4.
    induction Hwf using WFAdv_c_prop with
     (P0 := fun I i O (H:WFAdv_i PrOrcl PrPriv Gadv Gcomm e1 I i O) => 
      (slossless_i e1 i) -> 
      (forall x : VarP.Edec.t, Vset.mem x I -> Var.is_local x) -> 
      forall i', i=i' -> 
        ([| [i],[i'] |] <~ F [i] e1) /\ 
        (forall m, range (fun m' => S m m') ([[ [i] ]] e1 m))).
    (* nil *)
    intros c' Hc; subst; split.
      (* dist *)
      apply rtriple_weaken with (fzero _); [ unfold fzero; auto | ].
      apply rtriple_nil.
      (* range *)
      intros m f Hf; rewrite deno_nil_elim.
      apply (Hf _ (S_refl _)).

    (* cons *)
    intros c' Hc; subst.
    change (i::c) with ([i]++c).    
    inversion Hsl; subst; rename H2 into Hi_sl; rename H3 into Hc_sl; clear Hsl.
    destruct (IHHwf Hi_sl Hloc _ (eq_refl _)) as [H1 H2].
    destruct (IHHwf0 Hc_sl (fun x Hx => WFAdv_i_local w Hloc x Hx) _ (eq_refl _)) as [H4 H5].
    split.
      (* dist *)
      apply slossless_lossless in Hc_sl. 
      apply rtriple_weaken with (fun m => mu ([[ [i] ]] e1 m) (F c e1) + F [i] e1 m).  
        refine (ford_le_intro _); intro m; rewrite Uplus_sym; apply F_app_compat; assumption.
      apply rtriple_app; assumption.
      (* range *)
      intros m1 f Hf; rewrite deno_app_elim.
      apply H2.
      intros m2 Hm2; apply H5.
      intros m3 Hm3; apply (Hf _ (S_trans Hm2 Hm3)).

    (* assignment *)
    intros i' Hi; subst; split.
      (* dist *)
      apply rtriple_weaken with (fzero _); [ unfold fzero; auto | ].
      apply rtriple_ass.
      (* range *)
      intros m f Hf; rewrite deno_assign_elim.
      apply Hf.
      apply (S_compat_glob_var (S_refl m)).
        auto.
        intros t' x' Hx' H'.
        apply req_mem_upd_disjoint with (Vset.singleton x').
          apply not_true_is_false; destruct x; apply (@VsetP.singleton_mem_diff  x' v).
          intro H; rewrite <-H in w; elim H'; exact (w Hx').
          apply (Vset.singleton_correct (VarP.Edec.eq_refl x')). 

    (* random sampling *)
    intros i' Hi; subst; split.
      (* dist *)
      apply rtriple_weaken with (fzero _); [ unfold fzero; auto | ].
      apply rtriple_rand.
      (* range *)
      intros m f Hf.
      rewrite deno_random_elim.
      match goal with |- _ == fmonot (mu ?d) ?g =>
        rewrite <-(mu_0 d); apply mu_stable_eq; refine (ford_eq_intro _) 
      end.
      intro m'. 
      apply Hf.
      apply (S_compat_glob_var (S_refl m)).
        auto.
        intros t' x' Hx' H'.
        apply req_mem_upd_disjoint with {{x'}}.
          apply not_true_is_false; destruct x; apply (@VsetP.singleton_mem_diff  x' v).
          intro H; rewrite <-H in w; elim H'; exact (w Hx').
          apply (Vset.singleton_correct (VarP.Edec.eq_refl x')). 

    (* conditional *)
    intros i' Hi; subst.
    inversion Hsl; subst; rename H2 into Hc1_sl; rename H4 into Hc2_sl ; clear Hsl.
    destruct (IHHwf1 Hc1_sl Hloc _ (eq_refl _)) as [H1 H2]; clear IHHwf1.
    destruct (IHHwf2 Hc2_sl Hloc _ (eq_refl _)) as [H4 H5]; clear IHHwf2.
    split.
      (* dist *)
      unfold rtriple; intros m f.
      rewrite deno_cond_elim, deno_cond_elim, <-(F_if_compat); trivial.
      case (E.eval_expr e m); auto.
      (* range *)
      intros m f Hf; rewrite deno_cond_elim.
      case (E.eval_expr e m); [ exact (H2 m _ Hf) | exact (H5 m _ Hf) ].

    (* while *)
    intros i Hi; subst.
    inversion Hsl; subst; rename H3 into Hc_sl; rename H2 into Hi_sl; clear Hsl.
    destruct (IHHwf Hc_sl Hloc _ (eq_refl _)) as [H1 H2]; clear IHHwf.
    assert (Hran: forall m, range (fun m' => S m m') ([[ [while e do c] ]] e1 m)).
      intros m f Hf.
      rewrite deno_while_unfold_elim.
      split; [ trivial | apply lub_le; intro n; simpl; apply Oeq_le; symmetry ].
      apply (range_unroll_while _  H2). 
        intros m' H'.
        case (negP (E.eval_expr e) m'); [ apply (Hf _ H') | trivial ].
    split.
      (* dist *)
      eapply rtriple_weaken; [ | apply (@rtriple_while c c e (F c e1) H1)].
      unfold F; refine (ford_le_intro _); intro m.
      apply lub_le; intro n; simpl.
      generalize n m; clear n m.
      induction n; intros m; simpl.
        auto.
        rewrite (deno_while_elim _ _ _ m), (deno_cond_elim _ _ _ _ m).
        case (E.eval_expr e m).
          (* case [e] *)
          apply Ole_trans with ( mu ([[ c ]] e1 m) (F [while e do c] e1) + 
          F c e1 m); [ apply Uplus_le_compat; auto | ].
          rewrite Uplus_sym; apply F_app_compat; trivial.
          
          (* case [~e] *)
          trivial.
      (* range *)  
      exact Hran.
 
    (* oracle call *)
      intros i' Hi; subst;  split.
      (* dist *)
      intros m g.
      repeat rewrite deno_call_elim.
      rewrite <-(init_mem_eq2 e1 e2 f args args m); [ | auto | auto ].
      rewrite (mu_stable_eq ([[proc_body e2 f]] e2 (init_mem e1 f args m)) _ 
        (fun m' => g (return_mem e1 x f m m'))); [ | refine (ford_eq_intro _); 
          intro m'; rewrite (return_mem_eq e1 e2 f x m m'); auto ].  
      rewrite <-(F_calls_compat w0).
      apply Orcl_dist; assumption.
      (* range *)
      intros m g Hg; rewrite deno_call_elim.
      apply (Orcl_range _ i).  
      intros m' Hm'; apply Hg.
      apply (S_compat_glob_var Hm').
        apply init_mem_global.
        intros t' x' H1x' H2x'; symmetry.
        refine (return_mem_global _ _ _ _ _ H1x').
        intro H; rewrite H in w0; elim H2x'; exact (w0 H1x').

    (* other adversary call *)
    intros i' Hi; subst.
    inversion Hsl; subst.
    rename H1 into Hc_sl; clear Hsl x1 args1 H2  H4 f0.
    apply T.inj_pair2 in H3; subst.
    assert (H:forall x': VarP.Edec.t,
      Vset.mem x' (Vset_of_var_decl (proc_params e1 f)) -> Var.is_local x').
      intros (t0, x0) Hx0.
        apply Vset_of_var_decl_ind with (P:=fun t (x:Var.var t) => Var.is_local x) (lv:=proc_params e1 f).
          intros; change (Var.vis_local x1); apply proc_params_local with e1 t f; trivial.
          trivial.
    split.
      (* dist *)
      intros m g.
      repeat rewrite deno_call_elim.
      destruct (decl_Adv f n n0) as [f_params [f_body f_res] ].
      rewrite <-(init_mem_eq2 e1 e2 f args args m); trivial.
      rewrite (mu_stable_eq ([[proc_body e2 f]] e2 (init_mem e1 f args m)) _ 
        (fun m' => g (return_mem e1 x f m m'))); [ | refine (ford_eq_intro _); 
          intro m'; rewrite (return_mem_eq e1 e2 f x m m'); auto ].  
      rewrite <-(F_calls_compat w1).
      refine (proj1 (IHHwf Hc_sl H _ _) _ _); assumption.
      (* range *)
      intros m g Hg; rewrite deno_call_elim.
      apply ( (proj2 (IHHwf Hc_sl H _ (eq_refl _))) _).
      intros m' Hm'; apply Hg.
      apply (S_compat_glob_var Hm').
        apply init_mem_global.
        intros t' x' H1x' H2x'; symmetry.
        refine (return_mem_global _ _ _ _ _ H1x').
        intro H'; rewrite H' in w1; elim H2x'; exact (w1 H1x').
  Qed.


  Lemma rtriple_adv_Call : forall t (x:Var.var t) (A:Proc.proc t) arg,
     slossless_c e1 (proc_body e1 A) ->
     ~ PrSet.mem (BProc.mkP A) PrOrcl ->
     ~ PrSet.mem (BProc.mkP A) PrPriv ->
     WFAdv PrOrcl PrPriv Gadv Gcomm e1 A ->
     (forall x, Vset.mem x (Vset_of_var_decl (proc_params e1 A)) -> Var.is_local x) ->
     [| [x <c- A with arg], [x <c- A with arg]  |] <~ 
     fun m => F (proc_body e1 A) e1 (init_mem e1 A arg m). 
  Proof.
    intros t x A arg H0 H1 H2 [O [HWF H3] ] H4 m f.
    destruct (decl_Adv A H1 H2) as  [f_params [f_body f_res] ]. 
    repeat rewrite deno_call_elim.
    rewrite <-(init_mem_eq2 e1 e2 A arg arg m); [ | auto | auto ].
    rewrite (mu_stable_eq ([[proc_body e2 A]] e2 (init_mem e1 A arg m)) _ 
        (fun m' => f (return_mem e1 x A m m'))); [ | refine (ford_eq_intro _); 
          intro m'; rewrite (return_mem_eq e1 e2 A x m m'); auto ].  
    rewrite <-f_body.
    apply (proj1 (rtriple_adv HWF H0 H4)).
  Qed. 

 End  ADVERSARY.

End RTRIPLE.


 Lemma rtriple_refl_zero: forall (E:env) c k, 
  @rtriple k E E c c (fzero _).
 Proof.
  intros E c k m f; apply Oeq_le; apply Uabs_diff_zero.
  apply equiv_deno with Meq Meq.
  apply equiv_eq_mem.
  intros m1 m2 Hm; rewrite Hm; trivial.
  trivial.
 Qed.

 Lemma rtriple_sym: forall e1 c1 e2 c2 k g,
   @rtriple k e1 e2 c1 c2 g -> 
   @rtriple k e2 e1 c2 c1 g.
 Proof.
  unfold rtriple; intros.
  rewrite Uabs_diff_sym; auto.
 Qed.
  
 Lemma rtriple_trans: forall e1 c1 e2 c2 e3 c3 k g1 g2,
   @rtriple k e1 e2 c1 c2 g1 -> 
   @rtriple k e2 e3 c2 c3 g2 -> 
   @rtriple k e1 e3 c1 c3 (fplus g1 g2).
 Proof.
  intros.
  intros m f.
  rewrite (Uabs_diff_triangle_ineq _ _ (mu ([[c2]] e2 m) f)).
  apply Uplus_le_compat; auto.
 Qed.


 Lemma rtriple_deno: forall e1 c1 e2 c2 (ep:nat -o> U),
   (forall k, @rtriple k e1 e2 c1 c2 (fun _ => ep k)) <->
   prg_SD Meq e1 c1 e2 c2 Meq ep.
 Proof.
  unfold rtriple, prg_SD; split; intros.
    rewrite H1, (mu_stable_eq (([[ c2 ]]) e2 m2) g f); [ |
      refine (ford_eq_intro _); intro m; symmetry; apply H0; trivial ]. 
    apply H.

    apply H.
      intros m1 m2 Hm; rewrite Hm; trivial.
      trivial.
 Qed.

 Lemma rtriple_eq_deno_l: forall E1 E2 E3 c1 c2 c3 k g,
   equiv Meq E1 c1 E3 c3 Meq ->
   @rtriple k E3 E2 c3 c2 g ->
   @rtriple k E1 E2 c1 c2 g.
 Proof.
  intros. 
  apply rtriple_weaken with (fplus (fzero _) g).
    unfold fplus, fzero; auto.
  apply rtriple_trans with E3 c3.
    intros m f; unfold fzero; apply Oeq_le; rewrite Uabs_diff_zero.
    apply eq_distr_elim; apply (equiv_Meq_deno _ _ _ _ H).
    trivial.
 Qed.

 Lemma rtriple_eq_deno_r: forall E1 E2 E3 c1 c2 c3 k g,
   equiv Meq E2 c2 E3 c3 Meq ->
   @rtriple k E1 E3 c1 c3 g ->
   @rtriple k E1 E2 c1 c2 g.
 Proof.
  intros.
  apply rtriple_sym; apply rtriple_sym in H0.
  apply rtriple_eq_deno_l with E3 c3; trivial.
 Qed.


 Add Parametric Morphism k : (@rtriple k) with signature 
   (@eq env) ==> (@eq env) ==>
   (@eq cmd) ==> (@eq cmd) ==> (@Ole (ford (Mem.t k) (tcpo U))) ++>
    impl as rtriple_Ole_Morph.
 Proof.
  unfold impl; intros.
  refine (rtriple_weaken H H0).   
 Qed.   

 Add Parametric Morphism k : (@rtriple k) with signature 
   (@eq env) ==> (@eq env) ==>
   (@eq cmd) ==> (@eq cmd) ==> (@Oeq (ford (Mem.t k) (tcpo U))) ==>
    iff as rtriple_Oeq_Morph.
 Proof.
  unfold iff; split; intro.
   refine (rtriple_weaken (proj1 H) H0).   
   refine (rtriple_weaken (proj2 H) H0).   
 Qed.   


(* INSTANTIATION FOR THE RULE DEALING WITH A COUNTER *)
Section RTRIPLE_EXPR.

  Variables PrOrcl PrPriv : PrSet.t.
  Variables Gadv Gcomm :Vset.t.

 (* Hypotheses about the environments *)
  Variable e1 e2: env.
  Hypothesis procs_params_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_params e1 p = proc_params e2 p.
  Hypothesis procs_res_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_res e1 p = proc_res e2 p.
  Hypothesis decl_Adv: Eq_adv_decl PrOrcl PrPriv e1 e2.


  (* Invariant definition and properties *)
  Variable e : E.expr T.Nat.
  Variable X:Vset.t.
  Hypothesis X_dep_e: depend_only X e.
  Hypothesis X_global: forall x, Vset.mem x X -> Var.is_global x.
  Hypothesis X_Gadv: forall x, Vset.mem x X -> ~ Vset.mem x Gadv.
  Variable k:nat.
  Let S (m m':Mem.t k) := (E.eval_expr e m <= E.eval_expr e m')%nat.

  Hint Unfold S.

  Lemma S_compat_glob_var: forall (m1 m2 m1' m2':Mem.t k),
    S m1 m2 ->
    (forall t (x:Var.var t), Var.is_global x -> m1 x = m1' x) ->
    (forall t (x:Var.var t), Var.is_global x -> ~ Vset.mem x Gadv -> m2 x = m2' x) ->
    S m1' m2'.
  Proof.
   unfold S; intros m1 m2 m1' m2' H1 Hl Hr.
   rewrite <-(@X_dep_e _ m1 m1'); [ | intros t x Hx; auto ].
   rewrite <-(@X_dep_e _ m2 m2'); [ | intros t x Hx; auto ].
   assumption.
  Qed.

  Lemma S_refl: forall (m:Mem.t k), S m m. 
  Proof. auto. Qed.

  Lemma S_trans: forall (m1 m2 m3:Mem.t k),
    S m1 m2 -> S m2 m3 -> S m1 m3.
  Proof. eauto using le_trans. Qed.


  (* Bounding-function definition and properties *)
  Variable h: nat -> U.
  Hypothesis h_wretract: wretract h. 

  Lemma h_non_overflow: forall a b c,
     sum_f a b h <= [1-] sum_f b c h.
  Proof.
    apply wretract_sum_f; assumption.
  Qed.
   
  Let F  (c:cmd) (E:env) := 
     fun (m:Mem.t k) => mu ([[ c ]] E m)
       (fun m' => sum_f (E.eval_expr e m) (E.eval_expr e m') h).


  Lemma F_app: forall (c1 c1' : cmd),
    lossless e1 c1' ->
    (forall m, range (fun m' => S m m') ([[ c1 ]] e1 m)) ->
    (forall m, range (fun m' => S m m') ([[ c1' ]] e1 m)) ->
    forall (m:Mem.t k), 
      mu ([[c1]] e1 m) (F c1' e1) + F c1 e1 m == F (c1 ++ c1') e1 m.
  Proof.
   unfold F; intros  c1 c1' H1 H2 H3 m.
   rewrite deno_app_elim.
   transitivity (
      (mu ([[ c1 ]] e1 m) (fun m' => mu ([[c1']] e1 m') (fun m'' =>
        sum_f (E.eval_expr e m') (E.eval_expr e m'') h))) +
      (mu ([[ c1 ]] e1 m) (fun m' => mu ([[c1']] e1 m') (fcte _
        (sum_f (E.eval_expr e m) (E.eval_expr e m') h))))).
      (* left ineq *)
      apply Uplus_eq_compat.
        trivial.
        apply mu_stable_eq; refine (ford_eq_intro _); intros m'.
        rewrite mu_cte, (H1 _ m'); auto.
      (* right ineq *)
      rewrite <-(@mu_stable_plus _ _ _ _).
      apply (range_eq (H2 _)); intros m' Hm'; unfold fplus.
      rewrite <-mu_stable_plus_range; [ | apply (H3 _) |
        intros m'' Hm''; apply h_non_overflow  ].
        apply (range_eq (H3 _)); intros m'' Hm''; unfold fplus, fcte. 
        rewrite Uplus_sym; symmetry; apply sum_f_split; assumption.
      unfold fplusok; refine (ford_le_intro _); intro m''; unfold finv.
      apply mu_fplusok; unfold fplusok, finv, fcte.
      refine (ford_le_intro _); intro m'''.
      apply Uinv_le_perm_right; apply h_non_overflow.
  Qed.


  Lemma F_if: forall c1 c2 (b:E.expr T.Bool) (m:Mem.t k), 
    (if E.eval_expr b m then F c1 e1 m else F c2 e1 m) ==
    F [If b then c1 else c2] e1 m.
  Proof.
   unfold F; intros.
   rewrite deno_cond_elim; case (E.eval_expr b m); trivial.
  Qed.

  Lemma F_calls: forall t (x: Var.var t),
    WFWrite Gadv x ->
    forall (f: Proc.proc t) args (m:Mem.t k),
    F (proc_body e1 f) e1 (init_mem e1 f args m) == F [x <c- f with args] e1 m.
  Proof.
    unfold F; intros.
    rewrite deno_call_elim.
    apply mu_stable_eq; refine (ford_eq_intro _); intro m'.
    rewrite (@X_dep_e _ (init_mem e1 f args m) m).
    rewrite <-(@X_dep_e _ (return_mem e1 x f m m') m'); trivial.
      intros t' x' Hx'; apply return_mem_global.
        intro H'; rewrite H' in H; elim (X_Gadv _ Hx'); 
          exact (H (X_global _ Hx')).
        exact (X_global _ Hx').
      intros t' x' Hx'; apply (init_mem_global _ _ _ _ _ (X_global _ Hx')).
   Qed.

  Notation "'[|' c1 ',' c2  '|]' '<~' g" := (rtriple e1 e2 c1 c2 g) (at level 50).

  (* Hypotheses about the oracles *)  
  Hypothesis Orcl_dist: forall t  (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   [| (proc_body e1 p), (proc_body e2 p) |] <~ F (proc_body e1 p) e1.
  Hypothesis Orcl_range: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   forall m, range (fun m' => S m m') ([[proc_body e1 p]] e1 m).


  Lemma rtriple_adv_call_expr : forall t (x:Var.var t) (A:Proc.proc t) arg,
    slossless_c e1 (proc_body e1 A) ->
    ~ PrSet.mem (BProc.mkP A) PrOrcl ->
    ~ PrSet.mem (BProc.mkP A) PrPriv ->
    WFAdv PrOrcl PrPriv Gadv Gcomm e1 A ->
    (forall x, Vset.mem x (Vset_of_var_decl (proc_params e1 A)) -> Var.is_local x) ->
    [| [x <c- A with arg], [x <c- A with arg]  |] <~ 
    fun m => F (proc_body e1 A) e1 (init_mem e1 A arg m). 
   Proof.
    intros.
    eapply rtriple_adv_Call with (PrOrcl:=PrOrcl) (PrPriv:=PrPriv)
      (Gadv:=Gadv) (Gcomm:=Gcomm) (p:=fun m m' => 
        sum_f (E.eval_expr e m) (E.eval_expr e m') h) (S:=S); trivial.
      apply S_compat_glob_var.
      apply S_refl.
      apply S_trans.
      intros c1 c2 H4 H5 H6 m; rewrite Uplus_sym.
        apply (F_app H4 H5 H6).   
      intros c1 c2 b m; apply F_if.
      intros; apply Oeq_le; apply F_calls; assumption.
  Qed.

  Lemma rtriple_adv_Call_expr : forall t (x:Var.var t) (A:Proc.proc t) arg,
    slossless_c e1 (proc_body e1 A) ->
    ~ PrSet.mem (BProc.mkP A) PrOrcl ->
    ~ PrSet.mem (BProc.mkP A) PrPriv ->
    WFAdv PrOrcl PrPriv Gadv Gcomm e1 A ->
    (forall x, Vset.mem x (Vset_of_var_decl (proc_params e1 A)) -> Var.is_local x) ->
    [| [x <c- A with arg], [x <c- A with arg]  |] <~ 
     fun m => F (proc_body e1 A) e1 (init_mem e1 A arg m). 
  Proof.
    intros.
    apply rtriple_adv_Call with  (PrOrcl:=PrOrcl) (PrPriv:=PrPriv)
      (Gadv:=Gadv) (Gcomm:=Gcomm) (p:=fun m m' => 
        sum_f (E.eval_expr e m) (E.eval_expr e m') h) (S:=S); trivial.
      apply S_compat_glob_var.
      apply S_refl.
      apply S_trans.
      intros c1 c2 H4 H5 H6 m; rewrite Uplus_sym.
        apply (F_app H4 H5 H6).   
      intros c1 c2 b m; apply F_if.
      intros; apply Oeq_le; apply F_calls; assumption.
  Qed.


End RTRIPLE_EXPR.



Section RTRIPLE_EXPR_BOUNDED.
(* Particular case in which the there is a single oracle and
   the bounding function for this oracle has a special form
   that ensures it is a retract *)
  
  Variable t : T.type.
  Variable Orc : Proc.proc t.

  Let PrOrcl:= PrSet.singleton (BProc.mkP Orc).
  Variables PrPriv: PrSet.t.
  Variables Gadv Gcomm: Vset.t.


 (* Hypotheses about the environments *)
  Variables e1 e2: env.
  Hypothesis procs_params_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_params e1 p = proc_params e2 p.
  Hypothesis procs_res_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_res e1 p = proc_res e2 p.
  Hypothesis decl_Adv: Eq_adv_decl PrOrcl PrPriv e1 e2.


  (* Invariant definition and properties *)
  Variable e : E.expr T.Nat.
  Variable X:Vset.t.
  Hypothesis X_dep_e: depend_only X e.
  Hypothesis X_global: forall x, Vset.mem x X -> Var.is_global x.
  Hypothesis X_Gadv: forall x, Vset.mem x X -> ~ Vset.mem x Gadv.

  Variable k:nat.

  Variable MAX:nat.
  Variable N:U.
 
  Let h := fun n => if leb (S n) MAX then n*/N else 0.

  Lemma sigma_0_n: forall i,
   (sigma (fun n : nat => n */ N)) (S i) == i * S i */ ([1/2] * N).
  Proof.
   induction i.
     rewrite sigma_1; auto.
     rewrite sigma_S, IHi.
     setoid_replace (S i */ N) with (2 * (S i) */ ([1/2] * N)) by 
       (rewrite mult_comm, Nmult_mult_assoc, Nmult_Unth_simpl_left;trivial).
     rewrite <-plus_Nmult_distr; apply Nmult_eq_compat_left; trivial.
     ring.
  Qed.

  Lemma h_wretract: (MAX - 1) * MAX */ [1/2]*N < 1 -> wretract h.
  Proof.
   intros Hbound i.
   apply Uinv_le_perm_right.
   destruct i.
     (* i = 0 *)
     auto.
     (* i > 0 *)
     destruct (le_lt_dec  (S (S i)) MAX) as [H | H]; unfold h.
       (* [i+2<=MAX] *)
       assert (exists MAX', MAX = S (S MAX')) by
         (inversion H; [ eauto | inversion H0; [ exists (S i) | exists m0]; auto ]).
       destruct H0 as [MAX' HM]; subst; apply le_S_n in H.
       rewrite <-pred_of_minus, <-pred_Sn in Hbound.
       transitivity (sigma (fun n => n*/N) (S MAX')).
         apply (sigma_monot _ _ H). 
         intros n Hn; rewrite leb_correct; [ trivial | omega ].
       transitivity ([1-] (S MAX' */ N)).
         2:(rewrite leb_correct; [ Usimpl; auto | omega ]).
       rewrite sigma_0_n.
       apply Uplus_lt_Uinv.
       apply Ule_lt_trans with (2:=Hbound).
       setoid_replace (S MAX' */ N) with (2 * S MAX' */ ([1/2] * N)) by
         (rewrite mult_comm, Nmult_mult_assoc, Nmult_Unth_simpl_left;trivial).
       rewrite <-plus_Nmult_distr; apply Nmult_eq_compat_left; trivial.
       ring.
       (* [i+2>MAX] *)
       rewrite leb_correct_conv, Uinv_zero; trivial.
  Qed.

 
  Notation "'[|' c1 ',' c2  '|]' '<~' g" := (rtriple e1 e2 c1 c2 g) (at level 50).

  Let F  (c:cmd) := 
     fun (m:Mem.t k) => mu ([[ c ]] e1 m)
       (fun m' => sum_f (E.eval_expr e m) (E.eval_expr e m') h).

  Let S (m m':Mem.t k) := (E.eval_expr e m <= E.eval_expr e m')%nat.

  Hint Resolve  le_0_n.

  (* Hypotheses about the oracle *)  
  Hypothesis Orcl_dist:
   [| (proc_body e1 Orc), (proc_body e2 Orc) |] <~ F (proc_body e1 Orc).
  Hypothesis Orcl_range: 
    forall m, range (fun m' => S m m') ([[proc_body e1 Orc]] e1 m).

  Lemma rtriple_adv_retract : forall t (x:Var.var t) (A:Proc.proc t) arg,
    slossless_c e1 (proc_body e1 A) ->
    ~ PrSet.mem (BProc.mkP A) PrOrcl ->
    ~ PrSet.mem (BProc.mkP A) PrPriv ->
    WFAdv PrOrcl PrPriv Gadv Gcomm e1 A ->
    (forall x, Vset.mem x (Vset_of_var_decl (proc_params e1 A)) -> Var.is_local x) ->
    [| [x <c- A with arg], [x <c- A with arg]  |] <~ 
    (fcte (Mem.t k) ((MAX - 1) * MAX */ [1/2]*N)).
  Proof.
    intros; intros m f; unfold fcte.
    apply (Ueq_orc 1 ((MAX - 1) * MAX */ [1/2]*N)); [ auto | 
      intro HM; rewrite <-HM; trivial | intro HM; generalize m f; clear m f ]. 

    apply rtriple_weaken with (fun m => F (proc_body e1 A) (init_mem e1 A arg m)).
      unfold F, fcte; refine (ford_le_intro _); intro m.
      match goal with |- fmonot (mu ?d) _ <= ?x => rewrite <-(mu_cte_le d x) end.
      apply mu_monotonic; unfold fcte; refine (ford_le_intro _); intro m'.
      rewrite (@sum_f_monot _ _ 0 (E.eval_expr e m')); trivial.

      transitivity (sum_f 0 MAX h).
        destruct (E.eval_expr e m'); [ auto | ].
        destruct (le_lt_dec (Datatypes.S i) MAX) as [H' | H'].
          apply sum_f_monot; trivial.
          rewrite (@sum_f_split 0 (Datatypes.S i) MAX); [ | auto | omega ].
          rewrite (@sum_f_cte h MAX (Datatypes.S i) 0). 
            repeat Usimpl; trivial.
            intros n Hl Hu; unfold h; rewrite leb_correct_conv; [ trivial | omega ].
      transitivity (sum_f 0 MAX (fun n => n */ N )).
        apply sum_f_le_compat.
        intros n Hl Hu; unfold h; case (leb (Datatypes.S n) MAX); trivial.
      rewrite sum_f_0_sigma. 
      destruct MAX; [ | rewrite sigma_0_n, <-pred_of_minus, <-pred_Sn ]; auto.

      apply rtriple_adv_Call_expr with PrOrcl PrPriv Gadv Gcomm X; trivial.
      apply h_wretract; auto.
      unfold PrOrcl; intros t' p' Hp'.
      apply PrSet.singleton_complete in Hp'; inversion Hp'; assumption.
      unfold PrOrcl; intros t' p' Hp'.
      apply PrSet.singleton_complete in Hp'; inversion Hp'; assumption.
  Qed.
    
End RTRIPLE_EXPR_BOUNDED.


Section RTRIPLE_CTE.
(* Particular case in which the there is a single oracle and
   the bounding function is constant *)
  
  Variable t : T.type.
  Variable Orc : Proc.proc t.

  Let PrOrcl:= PrSet.singleton (BProc.mkP Orc).
  Variables PrPriv: PrSet.t.
  Variables Gadv Gcomm: Vset.t.


 (* Hypotheses about the environments *)
  Variables e1 e2: env.
  Hypothesis procs_params_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_params e1 p = proc_params e2 p.
  Hypothesis procs_res_Orc: forall t (p:Proc.proc t), 
   PrSet.mem (BProc.mkP p) PrOrcl ->
   proc_res e1 p = proc_res e2 p.
  Hypothesis decl_Adv: Eq_adv_decl PrOrcl PrPriv e1 e2.


  (* Invariant definition and properties *)
  Variable e : E.expr T.Nat.
  Variable X:Vset.t.
  Hypothesis X_dep_e: depend_only X e.
  Hypothesis X_global: forall x, Vset.mem x X -> Var.is_global x.
  Hypothesis X_Gadv: forall x, Vset.mem x X -> ~ Vset.mem x Gadv.

  Variable k:nat.

  Variable MAX:nat.
  Variable N:U.
 
  Let h := fun n => if leb (S n) MAX then N else 0.

  Lemma h_cte_wretract: MAX */ N < 1 -> wretract h.
  Proof.
   intros Hbound i.
   apply Uinv_le_perm_right.
   destruct i.
     (* i = 0 *)
     auto.
     (* i > 0 *)
     destruct (le_lt_dec  (S (S i)) MAX) as [H | H]; unfold h.
       (* [i+2<=MAX] *)
       rewrite (leb_correct _ _ H).
       assert (exists MAX', MAX = (S MAX')) by (inversion H; [
         eauto | inversion H0; [ exists (S (S i)) | exists (S m0)]; auto ]).
       destruct H0 as [MAX' HM]; subst; apply le_S_n in H.
       transitivity (sigma (fun _ : nat => N) MAX').
         apply (sigma_monot _ _ H). 
           intros n Hn; rewrite leb_correct; [ trivial | omega ].
       rewrite <-Nmult_sigma.
       apply Uplus_lt_Uinv.
       rewrite Uplus_sym, <-Nmult_S; assumption.
       (* [i+2>MAX] *)
       rewrite (leb_correct_conv _ _ H); auto.
  Qed.

 
  Notation "'[|' c1 ',' c2  '|]' '<~' g" := (rtriple e1 e2 c1 c2 g) (at level 50).

  Let F  (c:cmd) := 
     fun (m:Mem.t k) => mu ([[ c ]] e1 m)
       (fun m' => sum_f (E.eval_expr e m) (E.eval_expr e m') h).

  Let S (m m':Mem.t k) := (E.eval_expr e m <= E.eval_expr e m')%nat.

  Hint Resolve  le_0_n.

  (* Hypotheses about the oracle *)  
  Hypothesis Orcl_dist:
   [| (proc_body e1 Orc), (proc_body e2 Orc) |] <~ F (proc_body e1 Orc).
  Hypothesis Orcl_range: 
    forall m, range (fun m' => S m m') ([[proc_body e1 Orc]] e1 m).

  Lemma rtriple_adv_cte: forall t (x:Var.var t) (A:Proc.proc t) arg,
     slossless_c e1 (proc_body e1 A) ->
     ~ PrSet.mem (BProc.mkP A) PrOrcl ->
     ~ PrSet.mem (BProc.mkP A) PrPriv ->
     WFAdv PrOrcl PrPriv Gadv Gcomm e1 A ->
     (forall x, Vset.mem x (Vset_of_var_decl (proc_params e1 A)) -> Var.is_local x) ->
     [| [x <c- A with arg], [x <c- A with arg]  |] <~ 
     (fcte (Mem.t k) (MAX */N)).
  Proof.
    intros; intros m f; unfold fcte.
    apply (Ueq_orc 1 (MAX */ N)); [ auto | 
      intro HM; rewrite <-HM; trivial | intro HM; generalize m f; clear m f ].
    apply rtriple_weaken with (fun m => F (proc_body e1 A) (init_mem e1 A arg m)).
      unfold F, fcte; refine (ford_le_intro _); intro m.
      match goal with |- fmonot (mu ?d) _ <= ?x => rewrite <-(mu_cte_le d x) end.
      apply mu_monotonic; unfold fcte; refine (ford_le_intro _); intro m'.
      rewrite (@sum_f_monot _ _ 0 (E.eval_expr e m')); trivial.

      transitivity (sum_f 0 MAX h).
        destruct (E.eval_expr e m'); [ auto | ].
        destruct (le_lt_dec (Datatypes.S i) MAX) as [H' | H'].
          apply sum_f_monot; trivial.
          rewrite (@sum_f_split 0 (Datatypes.S i) MAX); [ | auto | omega ].
          rewrite (@sum_f_cte h MAX (Datatypes.S i) 0). 
            repeat Usimpl; trivial.
            intros n Hl Hu; unfold h; rewrite leb_correct_conv; [ trivial | omega ].
      transitivity (sum_f 0 MAX (fun n =>  N )).
        apply sum_f_le_compat.
        intros n Hl Hu; unfold h; case (leb (Datatypes.S n) MAX); trivial.
      rewrite sum_f_0_sigma, <-Nmult_sigma; trivial.

      apply rtriple_adv_Call_expr with PrOrcl PrPriv Gadv Gcomm X; trivial.
      apply h_cte_wretract; auto.
      unfold PrOrcl; intros t' p' Hp'.
      apply PrSet.singleton_complete in Hp'; inversion Hp'; assumption.
      unfold PrOrcl; intros t' p' Hp'.
      apply PrSet.singleton_complete in Hp'; inversion Hp'; assumption.
  Qed.
    
End RTRIPLE_CTE.


End Make.
